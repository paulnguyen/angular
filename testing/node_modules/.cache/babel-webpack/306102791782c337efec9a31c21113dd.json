{"ast":null,"code":"import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing'; // Other imports\n\nimport { TestBed } from '@angular/core/testing';\nimport { HttpClient, HttpResponse, HttpErrorResponse } from '@angular/common/http';\nimport { asyncData, asyncError } from '../../testing/async-observable-helpers';\nimport { HeroService } from './hero.service';\ndescribe('HeroesService (with spies)', () => {\n  let httpClientSpy;\n  let heroService;\n  beforeEach(() => {\n    // TODO: spy on other methods too\n    httpClientSpy = jasmine.createSpyObj('HttpClient', ['get']);\n    heroService = new HeroService(httpClientSpy);\n  });\n  it('should return expected heroes (HttpClient called once)', done => {\n    const expectedHeroes = [{\n      id: 1,\n      name: 'A'\n    }, {\n      id: 2,\n      name: 'B'\n    }];\n    httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));\n    heroService.getHeroes().subscribe(heroes => {\n      expect(heroes).toEqual(expectedHeroes, 'expected heroes');\n      done();\n    }, done.fail);\n    expect(httpClientSpy.get.calls.count()).toBe(1, 'one call');\n  });\n  it('should return an error when the server returns a 404', done => {\n    const errorResponse = new HttpErrorResponse({\n      error: 'test 404 error',\n      status: 404,\n      statusText: 'Not Found'\n    });\n    httpClientSpy.get.and.returnValue(asyncError(errorResponse));\n    heroService.getHeroes().subscribe(heroes => done.fail('expected an error, not heroes'), error => {\n      expect(error.message).toContain('test 404 error');\n      done();\n    });\n  });\n});\ndescribe('HeroesService (with mocks)', () => {\n  let httpClient;\n  let httpTestingController;\n  let heroService;\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      // Import the HttpClient mocking services\n      imports: [HttpClientTestingModule],\n      // Provide the service-under-test\n      providers: [HeroService]\n    }); // Inject the http, test controller, and service-under-test\n    // as they will be referenced by each test.\n\n    httpClient = TestBed.inject(HttpClient);\n    httpTestingController = TestBed.inject(HttpTestingController);\n    heroService = TestBed.inject(HeroService);\n  });\n  afterEach(() => {\n    // After every test, assert that there are no more pending requests.\n    httpTestingController.verify();\n  }); /// HeroService method tests begin ///\n\n  describe('#getHeroes', () => {\n    let expectedHeroes;\n    beforeEach(() => {\n      heroService = TestBed.inject(HeroService);\n      expectedHeroes = [{\n        id: 1,\n        name: 'A'\n      }, {\n        id: 2,\n        name: 'B'\n      }];\n    });\n    it('should return expected heroes (called once)', () => {\n      heroService.getHeroes().subscribe(heroes => expect(heroes).toEqual(expectedHeroes, 'should return expected heroes'), fail); // HeroService should have made one request to GET heroes from expected URL\n\n      const req = httpTestingController.expectOne(heroService.heroesUrl);\n      expect(req.request.method).toEqual('GET'); // Respond with the mock heroes\n\n      req.flush(expectedHeroes);\n    });\n    it('should be OK returning no heroes', () => {\n      heroService.getHeroes().subscribe(heroes => expect(heroes.length).toEqual(0, 'should have empty heroes array'), fail);\n      const req = httpTestingController.expectOne(heroService.heroesUrl);\n      req.flush([]); // Respond with no heroes\n    });\n    it('should turn 404 into a user-friendly error', () => {\n      const msg = 'Deliberate 404';\n      heroService.getHeroes().subscribe(heroes => fail('expected to fail'), error => expect(error.message).toContain(msg));\n      const req = httpTestingController.expectOne(heroService.heroesUrl); // respond with a 404 and the error message in the body\n\n      req.flush(msg, {\n        status: 404,\n        statusText: 'Not Found'\n      });\n    });\n    it('should return expected heroes (called multiple times)', () => {\n      heroService.getHeroes().subscribe();\n      heroService.getHeroes().subscribe();\n      heroService.getHeroes().subscribe(heroes => expect(heroes).toEqual(expectedHeroes, 'should return expected heroes'), fail);\n      const requests = httpTestingController.match(heroService.heroesUrl);\n      expect(requests.length).toEqual(3, 'calls to getHeroes()'); // Respond to each request with different mock hero results\n\n      requests[0].flush([]);\n      requests[1].flush([{\n        id: 1,\n        name: 'bob'\n      }]);\n      requests[2].flush(expectedHeroes);\n    });\n  });\n  describe('#updateHero', () => {\n    // Expecting the query form of URL so should not 404 when id not found\n    const makeUrl = id => `${heroService.heroesUrl}/?id=${id}`;\n\n    it('should update a hero and return it', () => {\n      const updateHero = {\n        id: 1,\n        name: 'A'\n      };\n      heroService.updateHero(updateHero).subscribe(data => expect(data).toEqual(updateHero, 'should return the hero'), fail); // HeroService should have made one request to PUT hero\n\n      const req = httpTestingController.expectOne(heroService.heroesUrl);\n      expect(req.request.method).toEqual('PUT');\n      expect(req.request.body).toEqual(updateHero); // Expect server to return the hero after PUT\n\n      const expectedResponse = new HttpResponse({\n        status: 200,\n        statusText: 'OK',\n        body: updateHero\n      });\n      req.event(expectedResponse);\n    });\n    it('should turn 404 error into user-facing error', () => {\n      const msg = 'Deliberate 404';\n      const updateHero = {\n        id: 1,\n        name: 'A'\n      };\n      heroService.updateHero(updateHero).subscribe(heroes => fail('expected to fail'), error => expect(error.message).toContain(msg));\n      const req = httpTestingController.expectOne(heroService.heroesUrl); // respond with a 404 and the error message in the body\n\n      req.flush(msg, {\n        status: 404,\n        statusText: 'Not Found'\n      });\n    });\n    it('should turn network error into user-facing error', () => {\n      const emsg = 'simulated network error';\n      const updateHero = {\n        id: 1,\n        name: 'A'\n      };\n      heroService.updateHero(updateHero).subscribe(heroes => fail('expected to fail'), error => expect(error.message).toContain(emsg));\n      const req = httpTestingController.expectOne(heroService.heroesUrl); // Create mock ErrorEvent, raised when something goes wrong at the network level.\n      // Connection timeout, DNS error, offline, etc\n\n      const errorEvent = new ErrorEvent('so sad', {\n        message: emsg,\n        // The rest of this is optional and not used.\n        // Just showing that you could provide this too.\n        filename: 'HeroService.ts',\n        lineno: 42,\n        colno: 21\n      }); // Respond with mock error\n\n      req.error(errorEvent);\n    });\n  }); // TODO: test other HeroService methods\n});","map":{"version":3,"sources":["/Users/paulnguyen/Desktop/SRC/angular/testing/src/app/model/hero.service.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\n\n// Other imports\nimport { TestBed } from '@angular/core/testing';\nimport { HttpClient, HttpResponse, HttpErrorResponse } from '@angular/common/http';\n\nimport { asyncData, asyncError } from '../../testing/async-observable-helpers';\n\nimport { Hero } from './hero';\nimport { HeroService } from './hero.service';\n\ndescribe ('HeroesService (with spies)', () => {\n  let httpClientSpy: { get: jasmine.Spy };\n  let heroService: HeroService;\n\n  beforeEach(() => {\n    // TODO: spy on other methods too\n    httpClientSpy = jasmine.createSpyObj('HttpClient', ['get']);\n    heroService = new HeroService(httpClientSpy as any);\n  });\n\n  it('should return expected heroes (HttpClient called once)', (done: DoneFn) => {\n    const expectedHeroes: Hero[] =\n      [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];\n\n    httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));\n\n    heroService.getHeroes().subscribe(\n      heroes => {\n        expect(heroes).toEqual(expectedHeroes, 'expected heroes');\n        done();\n      },\n      done.fail\n    );\n    expect(httpClientSpy.get.calls.count()).toBe(1, 'one call');\n  });\n\n  it('should return an error when the server returns a 404', (done: DoneFn) => {\n    const errorResponse = new HttpErrorResponse({\n      error: 'test 404 error',\n      status: 404, statusText: 'Not Found'\n    });\n\n    httpClientSpy.get.and.returnValue(asyncError(errorResponse));\n\n    heroService.getHeroes().subscribe(\n      heroes => done.fail('expected an error, not heroes'),\n      error  => {\n        expect(error.message).toContain('test 404 error');\n        done();\n      }\n    );\n  });\n\n});\n\ndescribe('HeroesService (with mocks)', () => {\n  let httpClient: HttpClient;\n  let httpTestingController: HttpTestingController;\n  let heroService: HeroService;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      // Import the HttpClient mocking services\n      imports: [ HttpClientTestingModule ],\n      // Provide the service-under-test\n      providers: [ HeroService ]\n    });\n\n    // Inject the http, test controller, and service-under-test\n    // as they will be referenced by each test.\n    httpClient = TestBed.inject(HttpClient);\n    httpTestingController = TestBed.inject(HttpTestingController);\n    heroService = TestBed.inject(HeroService);\n  });\n\n  afterEach(() => {\n    // After every test, assert that there are no more pending requests.\n    httpTestingController.verify();\n  });\n\n  /// HeroService method tests begin ///\n  describe('#getHeroes', () => {\n    let expectedHeroes: Hero[];\n\n    beforeEach(() => {\n      heroService = TestBed.inject(HeroService);\n      expectedHeroes = [\n        { id: 1, name: 'A' },\n        { id: 2, name: 'B' },\n       ] as Hero[];\n    });\n\n    it('should return expected heroes (called once)', () => {\n      heroService.getHeroes().subscribe(\n        heroes => expect(heroes).toEqual(expectedHeroes, 'should return expected heroes'),\n        fail\n      );\n\n      // HeroService should have made one request to GET heroes from expected URL\n      const req = httpTestingController.expectOne(heroService.heroesUrl);\n      expect(req.request.method).toEqual('GET');\n\n      // Respond with the mock heroes\n      req.flush(expectedHeroes);\n    });\n\n    it('should be OK returning no heroes', () => {\n      heroService.getHeroes().subscribe(\n        heroes => expect(heroes.length).toEqual(0, 'should have empty heroes array'),\n        fail\n      );\n\n      const req = httpTestingController.expectOne(heroService.heroesUrl);\n      req.flush([]); // Respond with no heroes\n    });\n\n    it('should turn 404 into a user-friendly error', () => {\n      const msg = 'Deliberate 404';\n      heroService.getHeroes().subscribe(\n        heroes => fail('expected to fail'),\n        error => expect(error.message).toContain(msg)\n      );\n\n      const req = httpTestingController.expectOne(heroService.heroesUrl);\n\n      // respond with a 404 and the error message in the body\n      req.flush(msg, {status: 404, statusText: 'Not Found'});\n    });\n\n    it('should return expected heroes (called multiple times)', () => {\n      heroService.getHeroes().subscribe();\n      heroService.getHeroes().subscribe();\n      heroService.getHeroes().subscribe(\n        heroes => expect(heroes).toEqual(expectedHeroes, 'should return expected heroes'),\n        fail\n      );\n\n      const requests = httpTestingController.match(heroService.heroesUrl);\n      expect(requests.length).toEqual(3, 'calls to getHeroes()');\n\n      // Respond to each request with different mock hero results\n      requests[0].flush([]);\n      requests[1].flush([{id: 1, name: 'bob'}]);\n      requests[2].flush(expectedHeroes);\n    });\n  });\n\n  describe('#updateHero', () => {\n    // Expecting the query form of URL so should not 404 when id not found\n    const makeUrl = (id: number) => `${heroService.heroesUrl}/?id=${id}`;\n\n    it('should update a hero and return it', () => {\n\n      const updateHero: Hero = { id: 1, name: 'A' };\n\n      heroService.updateHero(updateHero).subscribe(\n        data => expect(data).toEqual(updateHero, 'should return the hero'),\n        fail\n      );\n\n      // HeroService should have made one request to PUT hero\n      const req = httpTestingController.expectOne(heroService.heroesUrl);\n      expect(req.request.method).toEqual('PUT');\n      expect(req.request.body).toEqual(updateHero);\n\n      // Expect server to return the hero after PUT\n      const expectedResponse = new HttpResponse(\n        { status: 200, statusText: 'OK', body: updateHero });\n      req.event(expectedResponse);\n    });\n\n    it('should turn 404 error into user-facing error', () => {\n      const msg = 'Deliberate 404';\n      const updateHero: Hero = { id: 1, name: 'A' };\n      heroService.updateHero(updateHero).subscribe(\n        heroes => fail('expected to fail'),\n        error => expect(error.message).toContain(msg)\n      );\n\n      const req = httpTestingController.expectOne(heroService.heroesUrl);\n\n      // respond with a 404 and the error message in the body\n      req.flush(msg, {status: 404, statusText: 'Not Found'});\n    });\n\n    it('should turn network error into user-facing error', () => {\n      const emsg = 'simulated network error';\n\n      const updateHero: Hero = { id: 1, name: 'A' };\n      heroService.updateHero(updateHero).subscribe(\n        heroes => fail('expected to fail'),\n        error => expect(error.message).toContain(emsg)\n      );\n\n      const req = httpTestingController.expectOne(heroService.heroesUrl);\n\n      // Create mock ErrorEvent, raised when something goes wrong at the network level.\n      // Connection timeout, DNS error, offline, etc\n      const errorEvent = new ErrorEvent('so sad', {\n        message: emsg,\n        // The rest of this is optional and not used.\n        // Just showing that you could provide this too.\n        filename: 'HeroService.ts',\n        lineno: 42,\n        colno: 21\n      });\n\n      // Respond with mock error\n      req.error(errorEvent);\n    });\n  });\n\n  // TODO: test other HeroService methods\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}