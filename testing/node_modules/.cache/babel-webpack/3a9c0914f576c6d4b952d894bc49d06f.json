{"ast":null,"code":"// tslint:disable-next-line:no-unused-variable\nimport { fakeAsync, tick, waitForAsync } from '@angular/core/testing';\nimport { interval, of } from 'rxjs';\nimport { delay, take } from 'rxjs/operators';\ndescribe('Angular async helper', () => {\n  describe('async', () => {\n    let actuallyDone = false;\n    beforeEach(() => {\n      actuallyDone = false;\n    });\n    afterEach(() => {\n      expect(actuallyDone).toBe(true, 'actuallyDone should be true');\n    });\n    it('should run normal test', () => {\n      actuallyDone = true;\n    });\n    it('should run normal async test', done => {\n      setTimeout(() => {\n        actuallyDone = true;\n        done();\n      }, 0);\n    });\n    it('should run async test with task', waitForAsync(() => {\n      setTimeout(() => {\n        actuallyDone = true;\n      }, 0);\n    }));\n    it('should run async test with task', waitForAsync(() => {\n      const id = setInterval(() => {\n        actuallyDone = true;\n        clearInterval(id);\n      }, 100);\n    }));\n    it('should run async test with successful promise', waitForAsync(() => {\n      const p = new Promise(resolve => {\n        setTimeout(resolve, 10);\n      });\n      p.then(() => {\n        actuallyDone = true;\n      });\n    }));\n    it('should run async test with failed promise', waitForAsync(() => {\n      const p = new Promise((resolve, reject) => {\n        setTimeout(reject, 10);\n      });\n      p.catch(() => {\n        actuallyDone = true;\n      });\n    })); // Use done. Can also use async or fakeAsync.\n\n    it('should run async test with successful delayed Observable', done => {\n      const source = of(true).pipe(delay(10));\n      source.subscribe(val => actuallyDone = true, err => fail(err), done);\n    });\n    it('should run async test with successful delayed Observable', waitForAsync(() => {\n      const source = of(true).pipe(delay(10));\n      source.subscribe(val => actuallyDone = true, err => fail(err));\n    }));\n    it('should run async test with successful delayed Observable', fakeAsync(() => {\n      const source = of(true).pipe(delay(10));\n      source.subscribe(val => actuallyDone = true, err => fail(err));\n      tick(10);\n    }));\n  });\n  describe('fakeAsync', () => {\n    it('should run timeout callback with delay after call tick with millis', fakeAsync(() => {\n      let called = false;\n      setTimeout(() => {\n        called = true;\n      }, 100);\n      tick(100);\n      expect(called).toBe(true);\n    }));\n    it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => {\n      function nestedTimer(cb) {\n        setTimeout(() => setTimeout(() => cb()));\n      }\n\n      const callback = jasmine.createSpy('callback');\n      nestedTimer(callback);\n      expect(callback).not.toHaveBeenCalled();\n      tick(0); // the nested timeout will also be triggered\n\n      expect(callback).toHaveBeenCalled();\n    }));\n    it('should not run new macro task callback with delay after call tick with millis', fakeAsync(() => {\n      function nestedTimer(cb) {\n        setTimeout(() => setTimeout(() => cb()));\n      }\n\n      const callback = jasmine.createSpy('callback');\n      nestedTimer(callback);\n      expect(callback).not.toHaveBeenCalled();\n      tick(0, {\n        processNewMacroTasksSynchronously: false\n      }); // the nested timeout will not be triggered\n\n      expect(callback).not.toHaveBeenCalled();\n      tick(0);\n      expect(callback).toHaveBeenCalled();\n    }));\n    it('should get Date diff correctly in fakeAsync', fakeAsync(() => {\n      const start = Date.now();\n      tick(100);\n      const end = Date.now();\n      expect(end - start).toBe(100);\n    }));\n    it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => {\n      // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'\n      // to patch rxjs scheduler\n      let result = '';\n      of('hello').pipe(delay(1000)).subscribe(v => {\n        result = v;\n      });\n      expect(result).toBe('');\n      tick(1000);\n      expect(result).toBe('hello');\n      const start = new Date().getTime();\n      let dateDiff = 0;\n      interval(1000).pipe(take(2)).subscribe(() => dateDiff = new Date().getTime() - start);\n      tick(1000);\n      expect(dateDiff).toBe(1000);\n      tick(1000);\n      expect(dateDiff).toBe(2000);\n    }));\n  });\n  describe('use jasmine.clock()', () => {\n    // need to config __zone_symbol__fakeAsyncPatchLock flag\n    // before loading zone.js/testing\n    beforeEach(() => {\n      jasmine.clock().install();\n    });\n    afterEach(() => {\n      jasmine.clock().uninstall();\n    });\n    it('should auto enter fakeAsync', () => {\n      // is in fakeAsync now, don't need to call fakeAsync(testFn)\n      let called = false;\n      setTimeout(() => {\n        called = true;\n      }, 100);\n      jasmine.clock().tick(100);\n      expect(called).toBe(true);\n    });\n  });\n  describe('test jsonp', () => {\n    function jsonp(url, callback) {// do a jsonp call which is not zone aware\n    } // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag\n    // before loading zone.js/testing\n\n\n    it('should wait until promise.then is called', waitForAsync(() => {\n      let finished = false;\n      new Promise(res => {\n        jsonp('localhost:8080/jsonp', () => {\n          // success callback and resolve the promise\n          finished = true;\n          res();\n        });\n      }).then(() => {\n        // async will wait until promise.then is called\n        // if __zone_symbol__supportWaitUnResolvedChainedPromise is set\n        expect(finished).toBe(true);\n      });\n    }));\n  });\n});","map":{"version":3,"sources":["/Users/paulnguyen/Desktop/SRC/angular/testing/src/app/demo/async-helper.spec.ts"],"names":[],"mappings":"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","sourcesContent":["// tslint:disable-next-line:no-unused-variable\nimport {fakeAsync, tick, waitForAsync} from '@angular/core/testing';\nimport {interval, of} from 'rxjs';\nimport {delay, take} from 'rxjs/operators';\n\ndescribe('Angular async helper', () => {\n  describe('async', () => {\n    let actuallyDone = false;\n\n    beforeEach(() => {\n      actuallyDone = false;\n    });\n\n    afterEach(() => {\n      expect(actuallyDone).toBe(true, 'actuallyDone should be true');\n    });\n\n    it('should run normal test', () => {\n      actuallyDone = true;\n    });\n\n    it('should run normal async test', (done: DoneFn) => {\n      setTimeout(() => {\n        actuallyDone = true;\n        done();\n      }, 0);\n    });\n\n    it('should run async test with task', waitForAsync(() => {\n         setTimeout(() => {\n           actuallyDone = true;\n         }, 0);\n       }));\n\n    it('should run async test with task', waitForAsync(() => {\n         const id = setInterval(() => {\n           actuallyDone = true;\n           clearInterval(id);\n         }, 100);\n       }));\n\n    it('should run async test with successful promise', waitForAsync(() => {\n         const p = new Promise(resolve => {\n           setTimeout(resolve, 10);\n         });\n         p.then(() => {\n           actuallyDone = true;\n         });\n       }));\n\n    it('should run async test with failed promise', waitForAsync(() => {\n         const p = new Promise((resolve, reject) => {\n           setTimeout(reject, 10);\n         });\n         p.catch(() => {\n           actuallyDone = true;\n         });\n       }));\n\n    // Use done. Can also use async or fakeAsync.\n    it('should run async test with successful delayed Observable', (done: DoneFn) => {\n      const source = of(true).pipe(delay(10));\n      source.subscribe(val => actuallyDone = true, err => fail(err), done);\n    });\n\n    it('should run async test with successful delayed Observable', waitForAsync(() => {\n         const source = of(true).pipe(delay(10));\n         source.subscribe(val => actuallyDone = true, err => fail(err));\n       }));\n\n    it('should run async test with successful delayed Observable', fakeAsync(() => {\n         const source = of(true).pipe(delay(10));\n         source.subscribe(val => actuallyDone = true, err => fail(err));\n\n         tick(10);\n       }));\n  });\n\n  describe('fakeAsync', () => {\n    it('should run timeout callback with delay after call tick with millis', fakeAsync(() => {\n         let called = false;\n         setTimeout(() => {\n           called = true;\n         }, 100);\n         tick(100);\n         expect(called).toBe(true);\n       }));\n\n    it('should run new macro task callback with delay after call tick with millis',\n       fakeAsync(() => {\n         function nestedTimer(cb: () => any): void {\n           setTimeout(() => setTimeout(() => cb()));\n         }\n         const callback = jasmine.createSpy('callback');\n         nestedTimer(callback);\n         expect(callback).not.toHaveBeenCalled();\n         tick(0);\n         // the nested timeout will also be triggered\n         expect(callback).toHaveBeenCalled();\n       }));\n\n    it('should not run new macro task callback with delay after call tick with millis',\n       fakeAsync(() => {\n         function nestedTimer(cb: () => any): void {\n           setTimeout(() => setTimeout(() => cb()));\n         }\n         const callback = jasmine.createSpy('callback');\n         nestedTimer(callback);\n         expect(callback).not.toHaveBeenCalled();\n         tick(0, {processNewMacroTasksSynchronously: false});\n         // the nested timeout will not be triggered\n         expect(callback).not.toHaveBeenCalled();\n         tick(0);\n         expect(callback).toHaveBeenCalled();\n       }));\n\n    it('should get Date diff correctly in fakeAsync', fakeAsync(() => {\n         const start = Date.now();\n         tick(100);\n         const end = Date.now();\n         expect(end - start).toBe(100);\n       }));\n\n    it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => {\n         // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'\n         // to patch rxjs scheduler\n         let result = '';\n         of('hello').pipe(delay(1000)).subscribe(v => {\n           result = v;\n         });\n         expect(result).toBe('');\n         tick(1000);\n         expect(result).toBe('hello');\n\n         const start = new Date().getTime();\n         let dateDiff = 0;\n         interval(1000).pipe(take(2)).subscribe(() => dateDiff = (new Date().getTime() - start));\n\n         tick(1000);\n         expect(dateDiff).toBe(1000);\n         tick(1000);\n         expect(dateDiff).toBe(2000);\n       }));\n  });\n\n  describe('use jasmine.clock()', () => {\n    // need to config __zone_symbol__fakeAsyncPatchLock flag\n    // before loading zone.js/testing\n    beforeEach(() => {\n      jasmine.clock().install();\n    });\n    afterEach(() => {\n      jasmine.clock().uninstall();\n    });\n    it('should auto enter fakeAsync', () => {\n      // is in fakeAsync now, don't need to call fakeAsync(testFn)\n      let called = false;\n      setTimeout(() => {\n        called = true;\n      }, 100);\n      jasmine.clock().tick(100);\n      expect(called).toBe(true);\n    });\n  });\n\n  describe('test jsonp', () => {\n    function jsonp(url: string, callback: () => void) {\n      // do a jsonp call which is not zone aware\n    }\n    // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag\n    // before loading zone.js/testing\n    it('should wait until promise.then is called', waitForAsync(() => {\n         let finished = false;\n         new Promise<void>(res => {\n           jsonp('localhost:8080/jsonp', () => {\n             // success callback and resolve the promise\n             finished = true;\n             res();\n           });\n         }).then(() => {\n           // async will wait until promise.then is called\n           // if __zone_symbol__supportWaitUnResolvedChainedPromise is set\n           expect(finished).toBe(true);\n         });\n       }));\n  });\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}