{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { DemoModule, BankAccountComponent, BankAccountParentComponent, LightswitchComponent, Child1Component, Child2Component, Child3Component, MasterService, ValueService, ExternalTemplateComponent, InputComponent, IoComponent, IoParentComponent, MyIfComponent, MyIfChildComponent, MyIfParentComponent, NeedsContentComponent, ParentComponent, TestProvidersComponent, TestViewProvidersComponent, ReversePipeComponent, ShellComponent } from './demo';\nimport { By } from '@angular/platform-browser';\nimport { Component, Injectable } from '@angular/core';\nimport { FormsModule } from '@angular/forms'; // Forms symbols imported only for a specific test below\n\nimport { NgModel, NgControl } from '@angular/forms';\nimport { fakeAsync, inject, TestBed, tick, waitForAsync } from '@angular/core/testing';\nimport { addMatchers, click } from '../../testing';\nexport class NotProvided extends ValueService {}\nbeforeEach(addMatchers);\ndescribe('demo (with TestBed):', () => {\n  ////////  Service Tests  /////////////\n  describe('ValueService', () => {\n    let service;\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        providers: [ValueService]\n      });\n      service = TestBed.inject(ValueService);\n    });\n    it('should use ValueService', () => {\n      service = TestBed.inject(ValueService);\n      expect(service.getValue()).toBe('real value');\n    });\n    it('can inject a default value when service is not provided', () => {\n      expect(TestBed.inject(NotProvided, null)).toBeNull();\n    });\n    it('test should wait for ValueService.getPromiseValue', waitForAsync(() => {\n      service.getPromiseValue().then(value => expect(value).toBe('promise value'));\n    }));\n    it('test should wait for ValueService.getObservableValue', waitForAsync(() => {\n      service.getObservableValue().subscribe(value => expect(value).toBe('observable value'));\n    })); // Must use done. See https://github.com/angular/angular/issues/10127\n\n    it('test should wait for ValueService.getObservableDelayValue', done => {\n      service.getObservableDelayValue().subscribe(value => {\n        expect(value).toBe('observable delay value');\n        done();\n      });\n    });\n    it('should allow the use of fakeAsync', fakeAsync(() => {\n      let value;\n      service.getPromiseValue().then(val => value = val);\n      tick(); // Trigger JS engine cycle until all promises resolve.\n\n      expect(value).toBe('promise value');\n    }));\n  });\n  describe('MasterService', () => {\n    let masterService;\n    let valueServiceSpy;\n    beforeEach(() => {\n      const spy = jasmine.createSpyObj('ValueService', ['getValue']);\n      TestBed.configureTestingModule({\n        // Provide both the service-to-test and its (spy) dependency\n        providers: [MasterService, {\n          provide: ValueService,\n          useValue: spy\n        }]\n      }); // Inject both the service-to-test and its (spy) dependency\n\n      masterService = TestBed.inject(MasterService);\n      valueServiceSpy = TestBed.inject(ValueService);\n    });\n    it('#getValue should return stubbed value from a spy', () => {\n      const stubValue = 'stub value';\n      valueServiceSpy.getValue.and.returnValue(stubValue);\n      expect(masterService.getValue()).toBe(stubValue, 'service returned stub value');\n      expect(valueServiceSpy.getValue.calls.count()).toBe(1, 'spy method was called once');\n      expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue);\n    });\n  });\n  describe('use inject within `it`', () => {\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        providers: [ValueService]\n      });\n    });\n    it('should use modified providers', inject([ValueService], service => {\n      service.setValue('value modified in beforeEach');\n      expect(service.getValue()).toBe('value modified in beforeEach');\n    }));\n  });\n  describe('using waitForAsync(inject) within beforeEach', () => {\n    let serviceValue;\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        providers: [ValueService]\n      });\n    });\n    beforeEach(waitForAsync(inject([ValueService], service => {\n      service.getPromiseValue().then(value => serviceValue = value);\n    })));\n    it('should use asynchronously modified value ... in synchronous test', () => {\n      expect(serviceValue).toBe('promise value');\n    });\n  }); /////////// Component Tests //////////////////\n\n  describe('TestBed component tests', () => {\n    beforeEach(waitForAsync(() => {\n      TestBed.configureTestingModule({\n        imports: [DemoModule]\n      }) // Compile everything in DemoModule\n      .compileComponents();\n    }));\n    it('should create a component with inline template', () => {\n      const fixture = TestBed.createComponent(Child1Component);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('Child');\n    });\n    it('should create a component with external template', () => {\n      const fixture = TestBed.createComponent(ExternalTemplateComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('from external template');\n    });\n    it('should allow changing members of the component', () => {\n      const fixture = TestBed.createComponent(MyIfComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('MyIf()');\n      fixture.componentInstance.showMore = true;\n      fixture.detectChanges();\n      expect(fixture).toHaveText('MyIf(More)');\n    });\n    it('should create a nested component bound to inputs/outputs', () => {\n      const fixture = TestBed.createComponent(IoParentComponent);\n      fixture.detectChanges();\n      const heroes = fixture.debugElement.queryAll(By.css('.hero'));\n      expect(heroes.length).toBeGreaterThan(0, 'has heroes');\n      const comp = fixture.componentInstance;\n      const hero = comp.heroes[0];\n      click(heroes[0]);\n      fixture.detectChanges();\n      const selected = fixture.debugElement.query(By.css('p'));\n      expect(selected).toHaveText(hero.name);\n    });\n    it('can access the instance variable of an `*ngFor` row component', () => {\n      const fixture = TestBed.createComponent(IoParentComponent);\n      const comp = fixture.componentInstance;\n      const heroName = comp.heroes[0].name; // first hero's name\n\n      fixture.detectChanges();\n      const ngForRow = fixture.debugElement.query(By.directive(IoComponent)); // first hero ngForRow\n\n      const hero = ngForRow.context.hero; // the hero object passed into the row\n\n      expect(hero.name).toBe(heroName, 'ngRow.context.hero');\n      const rowComp = ngForRow.componentInstance; // jasmine.any is an \"instance-of-type\" test.\n\n      expect(rowComp).toEqual(jasmine.any(IoComponent), 'component is IoComp');\n      expect(rowComp.hero.name).toBe(heroName, 'component.hero');\n    });\n    it('should support clicking a button', () => {\n      const fixture = TestBed.createComponent(LightswitchComponent);\n      const btn = fixture.debugElement.query(By.css('button'));\n      const span = fixture.debugElement.query(By.css('span')).nativeElement;\n      fixture.detectChanges();\n      expect(span.textContent).toMatch(/is off/i, 'before click');\n      click(btn);\n      fixture.detectChanges();\n      expect(span.textContent).toMatch(/is on/i, 'after click');\n    }); // ngModel is async so we must wait for it with promise-based `whenStable`\n\n    it('should support entering text in input box (ngModel)', waitForAsync(() => {\n      const expectedOrigName = 'John';\n      const expectedNewName = 'Sally';\n      const fixture = TestBed.createComponent(InputComponent);\n      fixture.detectChanges();\n      const comp = fixture.componentInstance;\n      const input = fixture.debugElement.query(By.css('input')).nativeElement;\n      expect(comp.name).toBe(expectedOrigName, `At start name should be ${expectedOrigName} `); // wait until ngModel binds comp.name to input box\n\n      fixture.whenStable().then(() => {\n        expect(input.value).toBe(expectedOrigName, `After ngModel updates input box, input.value should be ${expectedOrigName} `); // simulate user entering new name in input\n\n        input.value = expectedNewName; // that change doesn't flow to the component immediately\n\n        expect(comp.name).toBe(expectedOrigName, `comp.name should still be ${expectedOrigName} after value change, before binding happens`); // Dispatch a DOM event so that Angular learns of input value change.\n        // then wait while ngModel pushes input.box value to comp.name\n        // In older browsers, such as IE, you might need a CustomEvent instead. See\n        // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n\n        input.dispatchEvent(new Event('input'));\n        return fixture.whenStable();\n      }).then(() => {\n        expect(comp.name).toBe(expectedNewName, `After ngModel updates the model, comp.name should be ${expectedNewName} `);\n      });\n    })); // fakeAsync version of ngModel input test enables sync test style\n    // synchronous `tick` replaces asynchronous promise-base `whenStable`\n\n    it('should support entering text in input box (ngModel) - fakeAsync', fakeAsync(() => {\n      const expectedOrigName = 'John';\n      const expectedNewName = 'Sally';\n      const fixture = TestBed.createComponent(InputComponent);\n      fixture.detectChanges();\n      const comp = fixture.componentInstance;\n      const input = fixture.debugElement.query(By.css('input')).nativeElement;\n      expect(comp.name).toBe(expectedOrigName, `At start name should be ${expectedOrigName} `); // wait until ngModel binds comp.name to input box\n\n      tick();\n      expect(input.value).toBe(expectedOrigName, `After ngModel updates input box, input.value should be ${expectedOrigName} `); // simulate user entering new name in input\n\n      input.value = expectedNewName; // that change doesn't flow to the component immediately\n\n      expect(comp.name).toBe(expectedOrigName, `comp.name should still be ${expectedOrigName} after value change, before binding happens`); // Dispatch a DOM event so that Angular learns of input value change.\n      // then wait a tick while ngModel pushes input.box value to comp.name\n      // In older browsers, such as IE, you might need a CustomEvent instead. See\n      // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n\n      input.dispatchEvent(new Event('input'));\n      tick();\n      expect(comp.name).toBe(expectedNewName, `After ngModel updates the model, comp.name should be ${expectedNewName} `);\n    }));\n    it('ReversePipeComp should reverse the input text', fakeAsync(() => {\n      const inputText = 'the quick brown fox.';\n      const expectedText = '.xof nworb kciuq eht';\n      const fixture = TestBed.createComponent(ReversePipeComponent);\n      fixture.detectChanges();\n      const comp = fixture.componentInstance;\n      const input = fixture.debugElement.query(By.css('input')).nativeElement;\n      const span = fixture.debugElement.query(By.css('span')).nativeElement; // simulate user entering new name in input\n\n      input.value = inputText; // Dispatch a DOM event so that Angular learns of input value change.\n      // then wait a tick while ngModel pushes input.box value to comp.text\n      // and Angular updates the output span\n      // In older browsers, such as IE, you might need a CustomEvent instead. See\n      // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n\n      input.dispatchEvent(new Event('input'));\n      tick();\n      fixture.detectChanges();\n      expect(span.textContent).toBe(expectedText, 'output span');\n      expect(comp.text).toBe(inputText, 'component.text');\n    })); // Use this technique to find attached directives of any kind\n\n    it('can examine attached directives and listeners', () => {\n      const fixture = TestBed.createComponent(InputComponent);\n      fixture.detectChanges();\n      const inputEl = fixture.debugElement.query(By.css('input'));\n      expect(inputEl.providerTokens).toContain(NgModel, 'NgModel directive');\n      const ngControl = inputEl.injector.get(NgControl);\n      expect(ngControl).toEqual(jasmine.any(NgControl), 'NgControl directive');\n      expect(inputEl.listeners.length).toBeGreaterThan(2, 'several listeners attached');\n    });\n    it('BankAccountComponent should set attributes, styles, classes, and properties', () => {\n      const fixture = TestBed.createComponent(BankAccountParentComponent);\n      fixture.detectChanges();\n      const comp = fixture.componentInstance; // the only child is debugElement of the BankAccount component\n\n      const el = fixture.debugElement.children[0];\n      const childComp = el.componentInstance;\n      expect(childComp).toEqual(jasmine.any(BankAccountComponent));\n      expect(el.context).toBe(childComp, 'context is the child component');\n      expect(el.attributes.account).toBe(childComp.id, 'account attribute');\n      expect(el.attributes.bank).toBe(childComp.bank, 'bank attribute');\n      expect(el.classes.closed).toBe(true, 'closed class');\n      expect(el.classes.open).toBeFalsy('open class');\n      expect(el.styles.color).toBe(comp.color, 'color style');\n      expect(el.styles.width).toBe(comp.width + 'px', 'width style'); // Removed on 12/02/2016 when ceased public discussion of the `Renderer`. Revive in future?\n      // expect(el.properties['customProperty']).toBe(true, 'customProperty');\n    });\n  });\n  describe('TestBed component overrides:', () => {\n    it('should override ChildComp\\'s template', () => {\n      const fixture = TestBed.configureTestingModule({\n        declarations: [Child1Component]\n      }).overrideComponent(Child1Component, {\n        set: {\n          template: '<span>Fake</span>'\n        }\n      }).createComponent(Child1Component);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('Fake');\n    });\n    it('should override TestProvidersComp\\'s ValueService provider', () => {\n      const fixture = TestBed.configureTestingModule({\n        declarations: [TestProvidersComponent]\n      }).overrideComponent(TestProvidersComponent, {\n        remove: {\n          providers: [ValueService]\n        },\n        add: {\n          providers: [{\n            provide: ValueService,\n            useClass: FakeValueService\n          }]\n        } // Or replace them all (this component has only one provider)\n        // set:    { providers: [{ provide: ValueService, useClass: FakeValueService }] },\n\n      }).createComponent(TestProvidersComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('injected value: faked value', 'text'); // Explore the providerTokens\n\n      const tokens = fixture.debugElement.providerTokens;\n      expect(tokens).toContain(fixture.componentInstance.constructor, 'component ctor');\n      expect(tokens).toContain(TestProvidersComponent, 'TestProvidersComp');\n      expect(tokens).toContain(ValueService, 'ValueService');\n    });\n    it('should override TestViewProvidersComp\\'s ValueService viewProvider', () => {\n      const fixture = TestBed.configureTestingModule({\n        declarations: [TestViewProvidersComponent]\n      }).overrideComponent(TestViewProvidersComponent, {\n        // remove: { viewProviders: [ValueService]},\n        // add:    { viewProviders: [{ provide: ValueService, useClass: FakeValueService }] },\n        // Or replace them all (this component has only one viewProvider)\n        set: {\n          viewProviders: [{\n            provide: ValueService,\n            useClass: FakeValueService\n          }]\n        }\n      }).createComponent(TestViewProvidersComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('injected value: faked value');\n    });\n    it('injected provider should not be same as component\\'s provider', () => {\n      // TestComponent is parent of TestProvidersComponent\n      let TestComponent = class TestComponent {};\n      TestComponent = __decorate([Component({\n        template: '<my-service-comp></my-service-comp>'\n      })], TestComponent); // 3 levels of ValueService provider: module, TestCompomponent, TestProvidersComponent\n\n      const fixture = TestBed.configureTestingModule({\n        declarations: [TestComponent, TestProvidersComponent],\n        providers: [ValueService]\n      }).overrideComponent(TestComponent, {\n        set: {\n          providers: [{\n            provide: ValueService,\n            useValue: {}\n          }]\n        }\n      }).overrideComponent(TestProvidersComponent, {\n        set: {\n          providers: [{\n            provide: ValueService,\n            useClass: FakeValueService\n          }]\n        }\n      }).createComponent(TestComponent);\n      let testBedProvider;\n      let tcProvider;\n      let tpcProvider; // `inject` uses TestBed's injector\n\n      inject([ValueService], s => testBedProvider = s)();\n      tcProvider = fixture.debugElement.injector.get(ValueService);\n      tpcProvider = fixture.debugElement.children[0].injector.get(ValueService);\n      expect(testBedProvider).not.toBe(tcProvider, 'testBed/tc not same providers');\n      expect(testBedProvider).not.toBe(tpcProvider, 'testBed/tpc not same providers');\n      expect(testBedProvider instanceof ValueService).toBe(true, 'testBedProvider is ValueService');\n      expect(tcProvider).toEqual({}, 'tcProvider is {}');\n      expect(tpcProvider instanceof FakeValueService).toBe(true, 'tpcProvider is FakeValueService');\n    });\n    it('can access template local variables as references', () => {\n      const fixture = TestBed.configureTestingModule({\n        declarations: [ShellComponent, NeedsContentComponent, Child1Component, Child2Component, Child3Component]\n      }).overrideComponent(ShellComponent, {\n        set: {\n          selector: 'test-shell',\n          template: `\n          <needs-content #nc>\n            <child-1 #content text=\"My\"></child-1>\n            <child-2 #content text=\"dog\"></child-2>\n            <child-2 text=\"has\"></child-2>\n            <child-3 #content text=\"fleas\"></child-3>\n            <div #content>!</div>\n          </needs-content>\n          `\n        }\n      }).createComponent(ShellComponent);\n      fixture.detectChanges(); // NeedsContentComp is the child of ShellComp\n\n      const el = fixture.debugElement.children[0];\n      const comp = el.componentInstance;\n      expect(comp.children.toArray().length).toBe(4, 'three different child components and an ElementRef with #content');\n      expect(el.references.nc).toBe(comp, '#nc reference to component'); // Filter for DebugElements with a #content reference\n\n      const contentRefs = el.queryAll(de => de.references.content);\n      expect(contentRefs.length).toBe(4, 'elements w/ a #content reference');\n    });\n  });\n  describe('nested (one-deep) component override', () => {\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [ParentComponent, FakeChildComponent]\n      });\n    });\n    it('ParentComp should use Fake Child component', () => {\n      const fixture = TestBed.createComponent(ParentComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('Parent(Fake Child)');\n    });\n  });\n  describe('nested (two-deep) component override', () => {\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [ParentComponent, FakeChildWithGrandchildComponent, FakeGrandchildComponent]\n      });\n    });\n    it('should use Fake Grandchild component', () => {\n      const fixture = TestBed.createComponent(ParentComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('Parent(Fake Child(Fake Grandchild))');\n    });\n  });\n  describe('lifecycle hooks w/ MyIfParentComp', () => {\n    let fixture;\n    let parent;\n    let child;\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        imports: [FormsModule],\n        declarations: [MyIfChildComponent, MyIfParentComponent]\n      });\n      fixture = TestBed.createComponent(MyIfParentComponent);\n      parent = fixture.componentInstance;\n    });\n    it('should instantiate parent component', () => {\n      expect(parent).not.toBeNull('parent component should exist');\n    });\n    it('parent component OnInit should NOT be called before first detectChanges()', () => {\n      expect(parent.ngOnInitCalled).toBe(false);\n    });\n    it('parent component OnInit should be called after first detectChanges()', () => {\n      fixture.detectChanges();\n      expect(parent.ngOnInitCalled).toBe(true);\n    });\n    it('child component should exist after OnInit', () => {\n      fixture.detectChanges();\n      getChild();\n      expect(child instanceof MyIfChildComponent).toBe(true, 'should create child');\n    });\n    it('should have called child component\\'s OnInit ', () => {\n      fixture.detectChanges();\n      getChild();\n      expect(child.ngOnInitCalled).toBe(true);\n    });\n    it('child component called OnChanges once', () => {\n      fixture.detectChanges();\n      getChild();\n      expect(child.ngOnChangesCounter).toBe(1);\n    });\n    it('changed parent value flows to child', () => {\n      fixture.detectChanges();\n      getChild();\n      parent.parentValue = 'foo';\n      fixture.detectChanges();\n      expect(child.ngOnChangesCounter).toBe(2, 'expected 2 changes: initial value and changed value');\n      expect(child.childValue).toBe('foo', 'childValue should eq changed parent value');\n    }); // must be async test to see child flow to parent\n\n    it('changed child value flows to parent', waitForAsync(() => {\n      fixture.detectChanges();\n      getChild();\n      child.childValue = 'bar';\n      return new Promise(resolve => {\n        // Wait one JS engine turn!\n        setTimeout(() => resolve(), 0);\n      }).then(() => {\n        fixture.detectChanges();\n        expect(child.ngOnChangesCounter).toBe(2, 'expected 2 changes: initial value and changed value');\n        expect(parent.parentValue).toBe('bar', 'parentValue should eq changed parent value');\n      });\n    }));\n    it('clicking \"Close Child\" triggers child OnDestroy', () => {\n      fixture.detectChanges();\n      getChild();\n      const btn = fixture.debugElement.query(By.css('button'));\n      click(btn);\n      fixture.detectChanges();\n      expect(child.ngOnDestroyCalled).toBe(true);\n    }); ////// helpers ///\n\n    /**\n     * Get the MyIfChildComp from parent; fail w/ good message if cannot.\n     */\n\n    function getChild() {\n      let childDe; // DebugElement that should hold the MyIfChildComp\n      // The Hard Way: requires detailed knowledge of the parent template\n\n      try {\n        childDe = fixture.debugElement.children[4].children[0];\n      } catch (err) {\n        /* we'll report the error */\n      } // DebugElement.queryAll: if we wanted all of many instances:\n\n\n      childDe = fixture.debugElement.queryAll(de => de.componentInstance instanceof MyIfChildComponent)[0]; // WE'LL USE THIS APPROACH !\n      // DebugElement.query: find first instance (if any)\n\n      childDe = fixture.debugElement.query(de => de.componentInstance instanceof MyIfChildComponent);\n\n      if (childDe && childDe.componentInstance) {\n        child = childDe.componentInstance;\n      } else {\n        fail('Unable to find MyIfChildComp within MyIfParentComp');\n      }\n\n      return child;\n    }\n  });\n}); ////////// Fakes ///////////\n\nlet FakeChildComponent = class FakeChildComponent {};\nFakeChildComponent = __decorate([Component({\n  selector: 'child-1',\n  template: `Fake Child`\n})], FakeChildComponent);\nlet FakeChildWithGrandchildComponent = class FakeChildWithGrandchildComponent {};\nFakeChildWithGrandchildComponent = __decorate([Component({\n  selector: 'child-1',\n  template: `Fake Child(<grandchild-1></grandchild-1>)`\n})], FakeChildWithGrandchildComponent);\nlet FakeGrandchildComponent = class FakeGrandchildComponent {};\nFakeGrandchildComponent = __decorate([Component({\n  selector: 'grandchild-1',\n  template: `Fake Grandchild`\n})], FakeGrandchildComponent);\nlet FakeValueService = class FakeValueService extends ValueService {\n  constructor() {\n    super(...arguments);\n    this.value = 'faked value';\n  }\n\n};\nFakeValueService = __decorate([Injectable()], FakeValueService);","map":{"version":3,"sources":["/Users/paulnguyen/Desktop/SRC/angular/testing/src/app/demo/demo.testbed.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  DemoModule,\n  BankAccountComponent, BankAccountParentComponent,\n  LightswitchComponent,\n  Child1Component, Child2Component, Child3Component,\n  MasterService,\n  ValueService,\n  ExternalTemplateComponent,\n  InputComponent,\n  IoComponent, IoParentComponent,\n  MyIfComponent, MyIfChildComponent, MyIfParentComponent,\n  NeedsContentComponent, ParentComponent,\n  TestProvidersComponent, TestViewProvidersComponent,\n  ReversePipeComponent, ShellComponent\n} from './demo';\n\nimport { By } from '@angular/platform-browser';\nimport { Component,\n         DebugElement,\n         Injectable } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\n// Forms symbols imported only for a specific test below\nimport { NgModel, NgControl } from '@angular/forms';\n\nimport {\n  ComponentFixture, fakeAsync, inject, TestBed, tick, waitForAsync\n} from '@angular/core/testing';\n\nimport { addMatchers, click } from '../../testing';\n\nexport class NotProvided extends ValueService { /* example below */ }\nbeforeEach(addMatchers);\n\ndescribe('demo (with TestBed):', () => {\n\n  ////////  Service Tests  /////////////\n\n  describe('ValueService', () => {\n\n    let service: ValueService;\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({ providers: [ValueService] });\n      service = TestBed.inject(ValueService);\n    });\n\n    it('should use ValueService', () => {\n      service = TestBed.inject(ValueService);\n      expect(service.getValue()).toBe('real value');\n    });\n\n    it('can inject a default value when service is not provided', () => {\n      expect(TestBed.inject(NotProvided, null)).toBeNull();\n    });\n\n    it('test should wait for ValueService.getPromiseValue', waitForAsync(() => {\n      service.getPromiseValue().then(\n        value => expect(value).toBe('promise value')\n      );\n    }));\n\n    it('test should wait for ValueService.getObservableValue', waitForAsync(() => {\n      service.getObservableValue().subscribe(\n        value => expect(value).toBe('observable value')\n      );\n    }));\n\n    // Must use done. See https://github.com/angular/angular/issues/10127\n    it('test should wait for ValueService.getObservableDelayValue', (done: DoneFn) => {\n      service.getObservableDelayValue().subscribe(value => {\n        expect(value).toBe('observable delay value');\n        done();\n      });\n    });\n\n    it('should allow the use of fakeAsync', fakeAsync(() => {\n      let value: any;\n      service.getPromiseValue().then((val: any) => value = val);\n      tick(); // Trigger JS engine cycle until all promises resolve.\n      expect(value).toBe('promise value');\n    }));\n  });\n\n  describe('MasterService', () => {\n    let masterService: MasterService;\n    let valueServiceSpy: jasmine.SpyObj<ValueService>;\n\n    beforeEach(() => {\n      const spy = jasmine.createSpyObj('ValueService', ['getValue']);\n\n      TestBed.configureTestingModule({\n        // Provide both the service-to-test and its (spy) dependency\n        providers: [\n          MasterService,\n          { provide: ValueService, useValue: spy }\n        ]\n      });\n      // Inject both the service-to-test and its (spy) dependency\n      masterService = TestBed.inject(MasterService);\n      valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj<ValueService>;\n    });\n\n    it('#getValue should return stubbed value from a spy', () => {\n      const stubValue = 'stub value';\n      valueServiceSpy.getValue.and.returnValue(stubValue);\n\n      expect(masterService.getValue())\n        .toBe(stubValue, 'service returned stub value');\n      expect(valueServiceSpy.getValue.calls.count())\n        .toBe(1, 'spy method was called once');\n      expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n        .toBe(stubValue);\n    });\n  });\n\n  describe('use inject within `it`', () => {\n    beforeEach(() => {\n      TestBed.configureTestingModule({ providers: [ValueService] });\n    });\n\n    it('should use modified providers',\n      inject([ValueService], (service: ValueService) => {\n        service.setValue('value modified in beforeEach');\n        expect(service.getValue())\n          .toBe('value modified in beforeEach');\n      })\n    );\n  });\n\n  describe('using waitForAsync(inject) within beforeEach', () => {\n    let serviceValue: string;\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({ providers: [ValueService] });\n    });\n\n    beforeEach(waitForAsync(inject([ValueService], (service: ValueService) => {\n      service.getPromiseValue().then(value => serviceValue = value);\n    })));\n\n    it('should use asynchronously modified value ... in synchronous test', () => {\n      expect(serviceValue).toBe('promise value');\n    });\n  });\n\n  /////////// Component Tests //////////////////\n\n  describe('TestBed component tests', () => {\n\n    beforeEach(waitForAsync(() => {\n      TestBed\n        .configureTestingModule({\n          imports: [DemoModule],\n        })\n        // Compile everything in DemoModule\n        .compileComponents();\n    }));\n\n    it('should create a component with inline template', () => {\n      const fixture = TestBed.createComponent(Child1Component);\n      fixture.detectChanges();\n\n      expect(fixture).toHaveText('Child');\n    });\n\n    it('should create a component with external template', () => {\n      const fixture = TestBed.createComponent(ExternalTemplateComponent);\n      fixture.detectChanges();\n\n      expect(fixture).toHaveText('from external template');\n    });\n\n    it('should allow changing members of the component', () => {\n      const fixture = TestBed.createComponent(MyIfComponent);\n\n      fixture.detectChanges();\n      expect(fixture).toHaveText('MyIf()');\n\n      fixture.componentInstance.showMore = true;\n      fixture.detectChanges();\n      expect(fixture).toHaveText('MyIf(More)');\n    });\n\n    it('should create a nested component bound to inputs/outputs', () => {\n      const fixture = TestBed.createComponent(IoParentComponent);\n\n      fixture.detectChanges();\n      const heroes = fixture.debugElement.queryAll(By.css('.hero'));\n      expect(heroes.length).toBeGreaterThan(0, 'has heroes');\n\n      const comp = fixture.componentInstance;\n      const hero = comp.heroes[0];\n\n      click(heroes[0]);\n      fixture.detectChanges();\n\n      const selected = fixture.debugElement.query(By.css('p'));\n      expect(selected).toHaveText(hero.name);\n    });\n\n    it('can access the instance variable of an `*ngFor` row component', () => {\n      const fixture = TestBed.createComponent(IoParentComponent);\n      const comp = fixture.componentInstance;\n      const heroName = comp.heroes[0].name; // first hero's name\n\n      fixture.detectChanges();\n      const ngForRow = fixture.debugElement.query(By.directive(IoComponent)); // first hero ngForRow\n\n      const hero = ngForRow.context.hero; // the hero object passed into the row\n      expect(hero.name).toBe(heroName, 'ngRow.context.hero');\n\n      const rowComp = ngForRow.componentInstance;\n      // jasmine.any is an \"instance-of-type\" test.\n      expect(rowComp).toEqual(jasmine.any(IoComponent), 'component is IoComp');\n      expect(rowComp.hero.name).toBe(heroName, 'component.hero');\n    });\n\n    it('should support clicking a button', () => {\n      const fixture = TestBed.createComponent(LightswitchComponent);\n      const btn = fixture.debugElement.query(By.css('button'));\n      const span = fixture.debugElement.query(By.css('span')).nativeElement;\n\n      fixture.detectChanges();\n      expect(span.textContent).toMatch(/is off/i, 'before click');\n\n      click(btn);\n      fixture.detectChanges();\n      expect(span.textContent).toMatch(/is on/i, 'after click');\n    });\n\n    // ngModel is async so we must wait for it with promise-based `whenStable`\n    it('should support entering text in input box (ngModel)', waitForAsync(() => {\n      const expectedOrigName = 'John';\n      const expectedNewName = 'Sally';\n\n      const fixture = TestBed.createComponent(InputComponent);\n      fixture.detectChanges();\n\n      const comp = fixture.componentInstance;\n      const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement;\n\n      expect(comp.name).toBe(expectedOrigName,\n        `At start name should be ${expectedOrigName} `);\n\n      // wait until ngModel binds comp.name to input box\n      fixture.whenStable().then(() => {\n        expect(input.value).toBe(expectedOrigName,\n          `After ngModel updates input box, input.value should be ${expectedOrigName} `);\n\n        // simulate user entering new name in input\n        input.value = expectedNewName;\n\n        // that change doesn't flow to the component immediately\n        expect(comp.name).toBe(expectedOrigName,\n          `comp.name should still be ${expectedOrigName} after value change, before binding happens`);\n\n        // Dispatch a DOM event so that Angular learns of input value change.\n        // then wait while ngModel pushes input.box value to comp.name\n        // In older browsers, such as IE, you might need a CustomEvent instead. See\n        // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n        input.dispatchEvent(new Event('input'));\n        return fixture.whenStable();\n      })\n        .then(() => {\n          expect(comp.name).toBe(expectedNewName,\n            `After ngModel updates the model, comp.name should be ${expectedNewName} `);\n        });\n    }));\n\n    // fakeAsync version of ngModel input test enables sync test style\n    // synchronous `tick` replaces asynchronous promise-base `whenStable`\n    it('should support entering text in input box (ngModel) - fakeAsync', fakeAsync(() => {\n      const expectedOrigName = 'John';\n      const expectedNewName = 'Sally';\n\n      const fixture = TestBed.createComponent(InputComponent);\n      fixture.detectChanges();\n\n      const comp =  fixture.componentInstance;\n      const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement;\n\n      expect(comp.name).toBe(expectedOrigName,\n        `At start name should be ${expectedOrigName} `);\n\n      // wait until ngModel binds comp.name to input box\n      tick();\n      expect(input.value).toBe(expectedOrigName,\n        `After ngModel updates input box, input.value should be ${expectedOrigName} `);\n\n      // simulate user entering new name in input\n      input.value = expectedNewName;\n\n      // that change doesn't flow to the component immediately\n      expect(comp.name).toBe(expectedOrigName,\n        `comp.name should still be ${expectedOrigName} after value change, before binding happens`);\n\n      // Dispatch a DOM event so that Angular learns of input value change.\n      // then wait a tick while ngModel pushes input.box value to comp.name\n      // In older browsers, such as IE, you might need a CustomEvent instead. See\n      // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n      input.dispatchEvent(new Event('input'));\n      tick();\n      expect(comp.name).toBe(expectedNewName,\n        `After ngModel updates the model, comp.name should be ${expectedNewName} `);\n    }));\n\n    it('ReversePipeComp should reverse the input text', fakeAsync(() => {\n      const inputText = 'the quick brown fox.';\n      const expectedText = '.xof nworb kciuq eht';\n\n      const fixture = TestBed.createComponent(ReversePipeComponent);\n      fixture.detectChanges();\n\n      const comp = fixture.componentInstance;\n      const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement;\n      const span = fixture.debugElement.query(By.css('span')).nativeElement as HTMLElement;\n\n      // simulate user entering new name in input\n      input.value = inputText;\n\n      // Dispatch a DOM event so that Angular learns of input value change.\n      // then wait a tick while ngModel pushes input.box value to comp.text\n      // and Angular updates the output span\n      // In older browsers, such as IE, you might need a CustomEvent instead. See\n      // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n      input.dispatchEvent(new Event('input'));\n      tick();\n      fixture.detectChanges();\n      expect(span.textContent).toBe(expectedText, 'output span');\n      expect(comp.text).toBe(inputText, 'component.text');\n    }));\n\n    // Use this technique to find attached directives of any kind\n    it('can examine attached directives and listeners', () => {\n      const fixture = TestBed.createComponent(InputComponent);\n      fixture.detectChanges();\n\n      const inputEl = fixture.debugElement.query(By.css('input'));\n\n      expect(inputEl.providerTokens).toContain(NgModel, 'NgModel directive');\n\n      const ngControl = inputEl.injector.get(NgControl);\n      expect(ngControl).toEqual(jasmine.any(NgControl), 'NgControl directive');\n\n      expect(inputEl.listeners.length).toBeGreaterThan(2, 'several listeners attached');\n    });\n\n    it('BankAccountComponent should set attributes, styles, classes, and properties', () => {\n      const fixture = TestBed.createComponent(BankAccountParentComponent);\n      fixture.detectChanges();\n      const comp = fixture.componentInstance;\n\n      // the only child is debugElement of the BankAccount component\n      const el = fixture.debugElement.children[0];\n      const childComp = el.componentInstance as BankAccountComponent;\n      expect(childComp).toEqual(jasmine.any(BankAccountComponent));\n\n      expect(el.context).toBe(childComp, 'context is the child component');\n\n      expect(el.attributes.account).toBe(childComp.id, 'account attribute');\n      expect(el.attributes.bank).toBe(childComp.bank, 'bank attribute');\n\n      expect(el.classes.closed).toBe(true, 'closed class');\n      expect(el.classes.open).toBeFalsy('open class');\n\n      expect(el.styles.color).toBe(comp.color, 'color style');\n      expect(el.styles.width).toBe(comp.width + 'px', 'width style');\n\n      // Removed on 12/02/2016 when ceased public discussion of the `Renderer`. Revive in future?\n      // expect(el.properties['customProperty']).toBe(true, 'customProperty');\n\n    });\n\n\n  });\n\n  describe('TestBed component overrides:', () => {\n\n    it('should override ChildComp\\'s template', () => {\n\n      const fixture = TestBed.configureTestingModule({\n        declarations: [Child1Component],\n      })\n        .overrideComponent(Child1Component, {\n          set: { template: '<span>Fake</span>' }\n        })\n        .createComponent(Child1Component);\n\n      fixture.detectChanges();\n      expect(fixture).toHaveText('Fake');\n    });\n\n    it('should override TestProvidersComp\\'s ValueService provider', () => {\n      const fixture = TestBed.configureTestingModule({\n        declarations: [TestProvidersComponent],\n      })\n        .overrideComponent(TestProvidersComponent, {\n          remove: { providers: [ValueService] },\n          add: { providers: [{ provide: ValueService, useClass: FakeValueService }] },\n\n          // Or replace them all (this component has only one provider)\n          // set:    { providers: [{ provide: ValueService, useClass: FakeValueService }] },\n        })\n        .createComponent(TestProvidersComponent);\n\n      fixture.detectChanges();\n      expect(fixture).toHaveText('injected value: faked value', 'text');\n\n      // Explore the providerTokens\n      const tokens = fixture.debugElement.providerTokens;\n      expect(tokens).toContain(fixture.componentInstance.constructor, 'component ctor');\n      expect(tokens).toContain(TestProvidersComponent, 'TestProvidersComp');\n      expect(tokens).toContain(ValueService, 'ValueService');\n    });\n\n    it('should override TestViewProvidersComp\\'s ValueService viewProvider', () => {\n      const fixture = TestBed.configureTestingModule({\n        declarations: [TestViewProvidersComponent],\n      })\n        .overrideComponent(TestViewProvidersComponent, {\n          // remove: { viewProviders: [ValueService]},\n          // add:    { viewProviders: [{ provide: ValueService, useClass: FakeValueService }] },\n\n          // Or replace them all (this component has only one viewProvider)\n          set: { viewProviders: [{ provide: ValueService, useClass: FakeValueService }] },\n        })\n        .createComponent(TestViewProvidersComponent);\n\n      fixture.detectChanges();\n      expect(fixture).toHaveText('injected value: faked value');\n    });\n\n    it('injected provider should not be same as component\\'s provider', () => {\n\n      // TestComponent is parent of TestProvidersComponent\n      @Component({ template: '<my-service-comp></my-service-comp>' })\n      class TestComponent { }\n\n      // 3 levels of ValueService provider: module, TestCompomponent, TestProvidersComponent\n      const fixture = TestBed.configureTestingModule({\n        declarations: [TestComponent, TestProvidersComponent],\n        providers: [ValueService]\n      })\n        .overrideComponent(TestComponent, {\n          set: { providers: [{ provide: ValueService, useValue: {} }] }\n        })\n        .overrideComponent(TestProvidersComponent, {\n          set: { providers: [{ provide: ValueService, useClass: FakeValueService }] }\n        })\n        .createComponent(TestComponent);\n\n      let testBedProvider!: ValueService;\n      let tcProvider: ValueService;\n      let tpcProvider: FakeValueService;\n\n      // `inject` uses TestBed's injector\n      inject([ValueService], (s: ValueService) => testBedProvider = s)();\n      tcProvider = fixture.debugElement.injector.get(ValueService) as ValueService;\n      tpcProvider = fixture.debugElement.children[0].injector.get(ValueService) as FakeValueService;\n\n      expect(testBedProvider).not.toBe(tcProvider, 'testBed/tc not same providers');\n      expect(testBedProvider).not.toBe(tpcProvider, 'testBed/tpc not same providers');\n\n      expect(testBedProvider instanceof ValueService).toBe(true, 'testBedProvider is ValueService');\n      expect(tcProvider).toEqual({} as ValueService, 'tcProvider is {}');\n      expect(tpcProvider instanceof FakeValueService).toBe(true, 'tpcProvider is FakeValueService');\n    });\n\n    it('can access template local variables as references', () => {\n      const fixture = TestBed.configureTestingModule({\n        declarations: [ShellComponent, NeedsContentComponent, Child1Component, Child2Component, Child3Component],\n      })\n        .overrideComponent(ShellComponent, {\n          set: {\n            selector: 'test-shell',\n            template: `\n          <needs-content #nc>\n            <child-1 #content text=\"My\"></child-1>\n            <child-2 #content text=\"dog\"></child-2>\n            <child-2 text=\"has\"></child-2>\n            <child-3 #content text=\"fleas\"></child-3>\n            <div #content>!</div>\n          </needs-content>\n          `\n          }\n        })\n        .createComponent(ShellComponent);\n\n      fixture.detectChanges();\n\n      // NeedsContentComp is the child of ShellComp\n      const el = fixture.debugElement.children[0];\n      const comp = el.componentInstance;\n\n      expect(comp.children.toArray().length).toBe(4,\n        'three different child components and an ElementRef with #content');\n\n      expect(el.references.nc).toBe(comp, '#nc reference to component');\n\n      // Filter for DebugElements with a #content reference\n      const contentRefs = el.queryAll( de => de.references.content);\n      expect(contentRefs.length).toBe(4, 'elements w/ a #content reference');\n    });\n\n  });\n\n  describe('nested (one-deep) component override', () => {\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [ParentComponent, FakeChildComponent]\n      });\n    });\n\n    it('ParentComp should use Fake Child component', () => {\n      const fixture = TestBed.createComponent(ParentComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('Parent(Fake Child)');\n    });\n  });\n\n  describe('nested (two-deep) component override', () => {\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [ParentComponent, FakeChildWithGrandchildComponent, FakeGrandchildComponent]\n      });\n    });\n\n    it('should use Fake Grandchild component', () => {\n      const fixture = TestBed.createComponent(ParentComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('Parent(Fake Child(Fake Grandchild))');\n    });\n  });\n\n  describe('lifecycle hooks w/ MyIfParentComp', () => {\n    let fixture: ComponentFixture<MyIfParentComponent>;\n    let parent: MyIfParentComponent;\n    let child: MyIfChildComponent;\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        imports: [FormsModule],\n        declarations: [MyIfChildComponent, MyIfParentComponent]\n      });\n\n      fixture = TestBed.createComponent(MyIfParentComponent);\n      parent = fixture.componentInstance;\n    });\n\n    it('should instantiate parent component', () => {\n      expect(parent).not.toBeNull('parent component should exist');\n    });\n\n    it('parent component OnInit should NOT be called before first detectChanges()', () => {\n      expect(parent.ngOnInitCalled).toBe(false);\n    });\n\n    it('parent component OnInit should be called after first detectChanges()', () => {\n      fixture.detectChanges();\n      expect(parent.ngOnInitCalled).toBe(true);\n    });\n\n    it('child component should exist after OnInit', () => {\n      fixture.detectChanges();\n      getChild();\n      expect(child instanceof MyIfChildComponent).toBe(true, 'should create child');\n    });\n\n    it('should have called child component\\'s OnInit ', () => {\n      fixture.detectChanges();\n      getChild();\n      expect(child.ngOnInitCalled).toBe(true);\n    });\n\n    it('child component called OnChanges once', () => {\n      fixture.detectChanges();\n      getChild();\n      expect(child.ngOnChangesCounter).toBe(1);\n    });\n\n    it('changed parent value flows to child', () => {\n      fixture.detectChanges();\n      getChild();\n\n      parent.parentValue = 'foo';\n      fixture.detectChanges();\n\n      expect(child.ngOnChangesCounter).toBe(2,\n        'expected 2 changes: initial value and changed value');\n      expect(child.childValue).toBe('foo',\n        'childValue should eq changed parent value');\n    });\n\n    // must be async test to see child flow to parent\n    it('changed child value flows to parent', waitForAsync(() => {\n      fixture.detectChanges();\n      getChild();\n\n      child.childValue = 'bar';\n\n      return new Promise<void>(resolve => {\n        // Wait one JS engine turn!\n        setTimeout(() => resolve(), 0);\n      })\n        .then(() => {\n          fixture.detectChanges();\n\n          expect(child.ngOnChangesCounter).toBe(2,\n            'expected 2 changes: initial value and changed value');\n          expect(parent.parentValue).toBe('bar',\n            'parentValue should eq changed parent value');\n        });\n\n    }));\n\n    it('clicking \"Close Child\" triggers child OnDestroy', () => {\n      fixture.detectChanges();\n      getChild();\n\n      const btn = fixture.debugElement.query(By.css('button'));\n      click(btn);\n\n      fixture.detectChanges();\n      expect(child.ngOnDestroyCalled).toBe(true);\n    });\n\n    ////// helpers ///\n    /**\n     * Get the MyIfChildComp from parent; fail w/ good message if cannot.\n     */\n    function getChild() {\n\n      let childDe: DebugElement; // DebugElement that should hold the MyIfChildComp\n\n      // The Hard Way: requires detailed knowledge of the parent template\n      try {\n        childDe = fixture.debugElement.children[4].children[0];\n      } catch (err) { /* we'll report the error */ }\n\n      // DebugElement.queryAll: if we wanted all of many instances:\n      childDe = fixture.debugElement\n        .queryAll(de => de.componentInstance instanceof MyIfChildComponent)[0];\n\n      // WE'LL USE THIS APPROACH !\n      // DebugElement.query: find first instance (if any)\n      childDe = fixture.debugElement\n        .query(de => de.componentInstance instanceof MyIfChildComponent);\n\n      if (childDe && childDe.componentInstance) {\n        child = childDe.componentInstance;\n      } else {\n        fail('Unable to find MyIfChildComp within MyIfParentComp');\n      }\n\n      return child;\n    }\n  });\n\n});\n////////// Fakes ///////////\n\n@Component({\n  selector: 'child-1',\n  template: `Fake Child`\n})\nclass FakeChildComponent { }\n\n@Component({\n  selector: 'child-1',\n  template: `Fake Child(<grandchild-1></grandchild-1>)`\n})\nclass FakeChildWithGrandchildComponent { }\n\n@Component({\n  selector: 'grandchild-1',\n  template: `Fake Grandchild`\n})\nclass FakeGrandchildComponent { }\n\n@Injectable()\nclass FakeValueService extends ValueService {\n  value = 'faked value';\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}